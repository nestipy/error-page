{
  "exception": "Unauthorized",
  "type": "HttpException",
  "message": "401 - Unauthorized ",
  "root": "/home/tsiresy/work/python/nestipy/example",
  "request": {
    "method": "GET",
    "host": "http://127.0.0.1:8000"
  },
  "traceback": [
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/router/router_proxy.py",
      "lineno": 117,
      "name": "request_handler",
      "code": "import dataclasses\nimport os\nimport sys\nimport traceback\nimport typing\nfrom typing import Type, Union\n\nfrom pydantic import BaseModel\n\nfrom nestipy.common.exception import HttpException\nfrom nestipy.common.exception.http import ExceptionDetail, RequestTrack, Traceback\nfrom nestipy.common.exception.message import HttpStatusMessages\nfrom nestipy.common.exception.status import HttpStatus\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.logger import logger\nfrom nestipy.common.utils import snakecase_to_camelcase\nfrom nestipy.core.exception.processor import ExceptionFilterHandler\nfrom nestipy.core.guards import GuardProcessor\nfrom nestipy.core.interceptor import RequestInterceptor\nfrom nestipy.core.middleware import MiddlewareExecutor\nfrom nestipy.core.template import TemplateRendererProcessor\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.ioc import RequestContextContainer\nfrom nestipy.types_ import NextFn, CallableHandler\nfrom .route_explorer import RouteExplorer\nfrom ..adapter.http_adapter import HttpAdapter\nfrom ..context.execution_context import ExecutionContext\nfrom ...openapi.openapi_docs.v3 import Operation, PathItem, Response as ApiResponse\n\n\nclass RouterProxy:\n    def __init__(self, router: HttpAdapter, ):\n        self.router = router\n        self._template_processor = TemplateRendererProcessor(router)\n\n    def apply_routes(self, modules: list[Union[Type, object]], prefix: str = \"\"):\n        _prefix: Union[str | None] = f\"/{prefix.strip('/')}\" if prefix is not None and prefix.strip() != \"\" else None\n        json_paths = {}\n        json_schemas = {}\n        for module_ref in modules:\n            routes = RouteExplorer.explore(module_ref)\n            for route in routes:\n                path = f\"{_prefix.rstrip('/')}/{route['path'].strip('/')}\".rstrip('/') if _prefix else route['path']\n                methods = route['request_method']\n                method_name = route['method_name']\n                controller = route['controller']\n                handler = self.create_request_handler(module_ref, controller, method_name)\n                for method in methods:\n                    getattr(self.router, method.lower())(path, handler, route)\n                    # OPEN API REGISTER\n                    if path in json_paths:\n                        route_path = json_paths[path]\n                    else:\n                        route_path = {}\n                    if \"responses\" not in route['openapi'].keys():\n                        route['openapi'][\"responses\"] = {200: ApiResponse()}\n                    json_schemas = {**json_schemas, **route['schemas']}\n                    if 'no_swagger' not in route['openapi'].keys():\n                        route_path[method.lower()] = Operation(\n                            **route['openapi'],\n                            summary=snakecase_to_camelcase(method_name)\n                        )\n                        json_paths[path] = route_path\n        paths = {}\n        for path, op in json_paths.items():\n            paths[path] = PathItem(**op)\n        return paths, json_schemas\n\n    def create_request_handler(\n            self,\n            module_ref: Type,\n            controller: Union[object, Type],\n            method_name: str\n    ) -> CallableHandler:\n\n        async def request_handler(req: \"Request\", res: \"Response\", next_fn: NextFn):\n\n            context_container = RequestContextContainer.get_instance()\n            container = NestipyContainer.get_instance()\n            controller_method_handler = getattr(controller, method_name)\n            execution_context = ExecutionContext(\n                self.router,\n                module_ref,\n                controller,\n                controller_method_handler,\n                req,\n                res\n            )\n            # setup container for query params, route params, request, response, session, etc..\n            context_container.set_execution_context(execution_context)\n            handler_response: Response\n            try:\n                # TODO : Refactor\n                guard_processor: GuardProcessor = await NestipyContainer.get_instance().get(GuardProcessor)\n                can_activate = await guard_processor.process(execution_context)\n                if not can_activate[0]:\n                    # Raise error\n                    raise HttpException(\n                        HttpStatus.UNAUTHORIZED,\n                        HttpStatusMessages.UNAUTHORIZED,\n                        details=f\"Not authorized from guard {can_activate[1]}\"\n                    )\n\n                # create next_function that call catch\n                async def next_fn_middleware(ex: typing.Any = None):\n                    if ex is not None:\n                        return await self._ensure_response(res, await next_fn(ex))\n                    return await container.get(controller, method_name)\n\n                async def next_fn_interceptor(ex: typing.Any = None):\n                    if ex is not None:\n                        return await self._ensure_response(res, await next_fn(ex))\n                    return await MiddlewareExecutor(req, res, next_fn_middleware).execute()\n\n                #  execute Interceptor by using middleware execution as next_handler\n                interceptor: RequestInterceptor = await container.get(RequestInterceptor)\n                result = await interceptor.intercept(execution_context, next_fn_interceptor)\n                if result is None:\n                    raise HttpException(\n                        HttpStatus.BAD_REQUEST,\n                        \"Handler not called because of interceptor: Invalid Request\"\n                    )\n                # process template rendering\n                if self._template_processor.can_process(controller_method_handler, result):\n                    result = await res.html(self._template_processor.render())\n                # transform result to response\n                handler_response = await self._ensure_response(res, result)\n\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                if not isinstance(e, HttpException):\n                    e = HttpException(HttpStatus.INTERNAL_SERVER_ERROR, str(e), str(tb))\n                track = self.get_full_traceback_details(req, e.message, os.getcwd())\n                e.track_back = track\n                # Call exception catch\n                exception_handler = await container.get(ExceptionFilterHandler)\n                result = await exception_handler.catch(e, execution_context)\n                if result:\n                    handler_response = await self._ensure_response(res, result)\n                else:\n                    handler_response = await self._ensure_response(res, await next_fn(e))\n            finally:\n                #  reset request context container\n                context_container.destroy()\n            return handler_response\n\n        return request_handler\n\n    @classmethod\n    async def _ensure_response(cls, res: \"Response\", result: Union[\"Response\", str, dict, list]) -> \"Response\":\n\n        if isinstance(result, (str, int, float)):\n            return await res.send(content=str(result))\n        elif isinstance(result, (list, dict)):\n            return await res.json(content=result)\n        elif dataclasses.is_dataclass(result):\n            return await res.json(\n                content=dataclasses.asdict(typing.cast(dataclasses.dataclass, result)),\n            )\n        elif isinstance(result, BaseModel):\n            return await res.json(content=result.dict())\n        elif isinstance(result, Response):\n            return result\n        else:\n            return await res.json(content={'error': 'Unknown response format'}, status_code=403)\n\n    @classmethod\n    def get_code_context(cls, filename, lineno, n):\n        try:\n            with open(filename, 'r') as file:\n                lines = file.readlines()\n            return ''.join(lines)\n        except Exception as e:\n            return f\"Could not read file {filename}: {str(e)}\"\n\n    @classmethod\n    def get_full_traceback_details(cls, req: Request, exception: typing.Any, file_path: str):\n        exc_type, exc_value, exc_tb = sys.exc_info()\n        traceback_details = []\n\n        # Extracting traceback details\n        tb = exc_tb\n        while tb is not None:\n            filename: str = tb.tb_frame.f_code.co_filename\n            frame_info = Traceback(\n                filename=f\"{filename.replace(file_path, '').strip('/')}\",\n                lineno=tb.tb_lineno,\n                name=tb.tb_frame.f_code.co_name,\n                code=cls.get_code_context(tb.tb_frame.f_code.co_filename, tb.tb_lineno, 5),\n                is_package=filename.startswith(file_path)\n            )\n            traceback_details.append(frame_info)\n            tb = tb.tb_next\n        return ExceptionDetail(\n            exception=exception,\n            type=exc_type.__name__,\n            root=file_path,\n            traceback=traceback_details,\n            request=RequestTrack(method=req.method, host=req.host),\n            message=str(exc_value)\n        )\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/interceptor/processor.py",
      "lineno": 47,
      "name": "intercept",
      "code": "from typing import TYPE_CHECKING\n\nfrom nestipy.common.decorator import Injectable\nfrom nestipy.common.helpers import SpecialProviderExtractor\nfrom nestipy.common.interceptor import NestipyInterceptor, InterceptorKey\nfrom nestipy.core.constant import APP_INTERCEPTOR\nfrom nestipy.core.context.execution_context import ExecutionContext\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.metadata import ClassMetadata, Reflect\n\nif TYPE_CHECKING:\n    from nestipy.types_.handler import NextFn\n\n\n@Injectable()\nclass RequestInterceptor(NestipyInterceptor, SpecialProviderExtractor):\n    context: ExecutionContext\n\n    def __init__(self):\n        self.container = NestipyContainer.get_instance()\n\n    async def intercept(self, context: ExecutionContext, next_fn: \"NextFn\"):\n        self.context = context\n        handler_module_class = context.get_module()\n        handler_class = context.get_class()\n        handler = context.get_handler()\n\n        global_interceptors = context.get_adapter().get_global_interceptors()\n        module_interceptors = self.extract_special_providers(\n            handler_module_class,\n            NestipyInterceptor,\n            APP_INTERCEPTOR\n        )\n        class_interceptors = Reflect.get_metadata(handler_class, InterceptorKey.Meta, [])\n        handler_interceptors = Reflect.get_metadata(handler, InterceptorKey.Meta, [])\n        all_interceptors = handler_interceptors + class_interceptors + module_interceptors + global_interceptors\n        # setup dependency as the same as the container\n        for intercept in all_interceptors:\n            if issubclass(intercept, NestipyInterceptor):\n                # Put dependency\n                services = self.container.get_all_services()\n                Reflect.set_metadata(\n                    intercept, ClassMetadata.Metadata,\n                    ClassMetadata(handler_class, global_providers=services)\n                )\n\n        return await self._recursive_aplly_interceptor(0, all_interceptors, next_fn)\n\n    async def _recursive_aplly_interceptor(self, index: int, all_interceptors: list, next_fn: \"NextFn\"):\n        if len(all_interceptors) > index:\n            interceptor = all_interceptors[index]\n            instance: NestipyInterceptor = await self.container.get(interceptor)\n\n            async def _next_fn():\n                return await instance.intercept(self.context, next_fn)\n\n            return await self._recursive_aplly_interceptor(index + 1, all_interceptors, _next_fn)\n        else:\n            return await next_fn()\n\n\n__all__ = [\n    \"RequestInterceptor\"\n]\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/interceptor/processor.py",
      "lineno": 57,
      "name": "_recursive_aplly_interceptor",
      "code": "from typing import TYPE_CHECKING\n\nfrom nestipy.common.decorator import Injectable\nfrom nestipy.common.helpers import SpecialProviderExtractor\nfrom nestipy.common.interceptor import NestipyInterceptor, InterceptorKey\nfrom nestipy.core.constant import APP_INTERCEPTOR\nfrom nestipy.core.context.execution_context import ExecutionContext\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.metadata import ClassMetadata, Reflect\n\nif TYPE_CHECKING:\n    from nestipy.types_.handler import NextFn\n\n\n@Injectable()\nclass RequestInterceptor(NestipyInterceptor, SpecialProviderExtractor):\n    context: ExecutionContext\n\n    def __init__(self):\n        self.container = NestipyContainer.get_instance()\n\n    async def intercept(self, context: ExecutionContext, next_fn: \"NextFn\"):\n        self.context = context\n        handler_module_class = context.get_module()\n        handler_class = context.get_class()\n        handler = context.get_handler()\n\n        global_interceptors = context.get_adapter().get_global_interceptors()\n        module_interceptors = self.extract_special_providers(\n            handler_module_class,\n            NestipyInterceptor,\n            APP_INTERCEPTOR\n        )\n        class_interceptors = Reflect.get_metadata(handler_class, InterceptorKey.Meta, [])\n        handler_interceptors = Reflect.get_metadata(handler, InterceptorKey.Meta, [])\n        all_interceptors = handler_interceptors + class_interceptors + module_interceptors + global_interceptors\n        # setup dependency as the same as the container\n        for intercept in all_interceptors:\n            if issubclass(intercept, NestipyInterceptor):\n                # Put dependency\n                services = self.container.get_all_services()\n                Reflect.set_metadata(\n                    intercept, ClassMetadata.Metadata,\n                    ClassMetadata(handler_class, global_providers=services)\n                )\n\n        return await self._recursive_aplly_interceptor(0, all_interceptors, next_fn)\n\n    async def _recursive_aplly_interceptor(self, index: int, all_interceptors: list, next_fn: \"NextFn\"):\n        if len(all_interceptors) > index:\n            interceptor = all_interceptors[index]\n            instance: NestipyInterceptor = await self.container.get(interceptor)\n\n            async def _next_fn():\n                return await instance.intercept(self.context, next_fn)\n\n            return await self._recursive_aplly_interceptor(index + 1, all_interceptors, _next_fn)\n        else:\n            return await next_fn()\n\n\n__all__ = [\n    \"RequestInterceptor\"\n]\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/interceptor/processor.py",
      "lineno": 59,
      "name": "_recursive_aplly_interceptor",
      "code": "from typing import TYPE_CHECKING\n\nfrom nestipy.common.decorator import Injectable\nfrom nestipy.common.helpers import SpecialProviderExtractor\nfrom nestipy.common.interceptor import NestipyInterceptor, InterceptorKey\nfrom nestipy.core.constant import APP_INTERCEPTOR\nfrom nestipy.core.context.execution_context import ExecutionContext\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.metadata import ClassMetadata, Reflect\n\nif TYPE_CHECKING:\n    from nestipy.types_.handler import NextFn\n\n\n@Injectable()\nclass RequestInterceptor(NestipyInterceptor, SpecialProviderExtractor):\n    context: ExecutionContext\n\n    def __init__(self):\n        self.container = NestipyContainer.get_instance()\n\n    async def intercept(self, context: ExecutionContext, next_fn: \"NextFn\"):\n        self.context = context\n        handler_module_class = context.get_module()\n        handler_class = context.get_class()\n        handler = context.get_handler()\n\n        global_interceptors = context.get_adapter().get_global_interceptors()\n        module_interceptors = self.extract_special_providers(\n            handler_module_class,\n            NestipyInterceptor,\n            APP_INTERCEPTOR\n        )\n        class_interceptors = Reflect.get_metadata(handler_class, InterceptorKey.Meta, [])\n        handler_interceptors = Reflect.get_metadata(handler, InterceptorKey.Meta, [])\n        all_interceptors = handler_interceptors + class_interceptors + module_interceptors + global_interceptors\n        # setup dependency as the same as the container\n        for intercept in all_interceptors:\n            if issubclass(intercept, NestipyInterceptor):\n                # Put dependency\n                services = self.container.get_all_services()\n                Reflect.set_metadata(\n                    intercept, ClassMetadata.Metadata,\n                    ClassMetadata(handler_class, global_providers=services)\n                )\n\n        return await self._recursive_aplly_interceptor(0, all_interceptors, next_fn)\n\n    async def _recursive_aplly_interceptor(self, index: int, all_interceptors: list, next_fn: \"NextFn\"):\n        if len(all_interceptors) > index:\n            interceptor = all_interceptors[index]\n            instance: NestipyInterceptor = await self.container.get(interceptor)\n\n            async def _next_fn():\n                return await instance.intercept(self.context, next_fn)\n\n            return await self._recursive_aplly_interceptor(index + 1, all_interceptors, _next_fn)\n        else:\n            return await next_fn()\n\n\n__all__ = [\n    \"RequestInterceptor\"\n]\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/interceptor/processor.py",
      "lineno": 55,
      "name": "_next_fn",
      "code": "from typing import TYPE_CHECKING\n\nfrom nestipy.common.decorator import Injectable\nfrom nestipy.common.helpers import SpecialProviderExtractor\nfrom nestipy.common.interceptor import NestipyInterceptor, InterceptorKey\nfrom nestipy.core.constant import APP_INTERCEPTOR\nfrom nestipy.core.context.execution_context import ExecutionContext\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.metadata import ClassMetadata, Reflect\n\nif TYPE_CHECKING:\n    from nestipy.types_.handler import NextFn\n\n\n@Injectable()\nclass RequestInterceptor(NestipyInterceptor, SpecialProviderExtractor):\n    context: ExecutionContext\n\n    def __init__(self):\n        self.container = NestipyContainer.get_instance()\n\n    async def intercept(self, context: ExecutionContext, next_fn: \"NextFn\"):\n        self.context = context\n        handler_module_class = context.get_module()\n        handler_class = context.get_class()\n        handler = context.get_handler()\n\n        global_interceptors = context.get_adapter().get_global_interceptors()\n        module_interceptors = self.extract_special_providers(\n            handler_module_class,\n            NestipyInterceptor,\n            APP_INTERCEPTOR\n        )\n        class_interceptors = Reflect.get_metadata(handler_class, InterceptorKey.Meta, [])\n        handler_interceptors = Reflect.get_metadata(handler, InterceptorKey.Meta, [])\n        all_interceptors = handler_interceptors + class_interceptors + module_interceptors + global_interceptors\n        # setup dependency as the same as the container\n        for intercept in all_interceptors:\n            if issubclass(intercept, NestipyInterceptor):\n                # Put dependency\n                services = self.container.get_all_services()\n                Reflect.set_metadata(\n                    intercept, ClassMetadata.Metadata,\n                    ClassMetadata(handler_class, global_providers=services)\n                )\n\n        return await self._recursive_aplly_interceptor(0, all_interceptors, next_fn)\n\n    async def _recursive_aplly_interceptor(self, index: int, all_interceptors: list, next_fn: \"NextFn\"):\n        if len(all_interceptors) > index:\n            interceptor = all_interceptors[index]\n            instance: NestipyInterceptor = await self.container.get(interceptor)\n\n            async def _next_fn():\n                return await instance.intercept(self.context, next_fn)\n\n            return await self._recursive_aplly_interceptor(index + 1, all_interceptors, _next_fn)\n        else:\n            return await next_fn()\n\n\n__all__ = [\n    \"RequestInterceptor\"\n]\n",
      "is_package": false
    },
    {
      "filename": "app_controller.py",
      "lineno": 66,
      "name": "intercept",
      "code": "import dataclasses\nimport os.path\nimport shutil\nfrom typing import Any, Annotated, Optional, Type\n\nfrom pydantic import BaseModel\n\nfrom app_provider import AppProvider\nfrom nestipy.common import Controller, Injectable, Post, Get, logger, UploadFile, HttpStatus, HttpStatusMessages\nfrom nestipy.common import ExceptionFilter, Catch, UseFilters\nfrom nestipy.common import HttpException, apply_decorators\nfrom nestipy.common import NestipyInterceptor, UseInterceptors, Render\nfrom nestipy.common import Request, Response\nfrom nestipy.core import ArgumentHost, ExecutionContext\nfrom nestipy.ioc import Inject, Req, Res, Body, Cookie, Session, Header, create_type_annotated, RequestContextContainer\nfrom nestipy.openapi import ApiResponse, ApiParameter, ApiConsumer\nfrom nestipy.openapi import ApiTags, ApiOkResponse, ApiNotFoundResponse, ApiCreatedResponse, NoSwagger, ApiBody\nfrom nestipy.openapi.openapi_docs.v3 import Parameter, ParameterLocation, Schema\nfrom nestipy.types_ import NextFn\n\n\ndef user_callback(_name: str, _token: Optional[str], _type_ref: Type, _request_context: RequestContextContainer):\n    return \"User\"\n\n\nUser = create_type_annotated(user_callback, \"user\")\n\n\nclass Test2(BaseModel):\n    name2: str\n\n\n@dataclasses.dataclass\nclass Test3:\n    name3: str\n\n\nclass TestBody(BaseModel):\n    image: UploadFile\n    test2: Test2\n    test3: Test3\n\n\nclass UnauthorizedResponse(BaseModel):\n    status: int = 401\n    message: str\n    details: str\n\n\n@Catch()\nclass HttpExceptionFilter(ExceptionFilter):\n    async def catch(self, exception: HttpException, host: ArgumentHost) -> Any:\n        print('Catcher')\n\n\n@Catch()\nclass Http2ExceptionFilter(ExceptionFilter):\n    async def catch(self, exception: HttpException, host: ArgumentHost) -> Any:\n        print('Catcher2')\n        return None\n\n\n@Injectable()\nclass TestInterceptor(NestipyInterceptor):\n    async def intercept(self, context: ExecutionContext, next_fn: NextFn):\n        return await next_fn()\n\n\n@Injectable()\nclass TestMethodInterceptor(NestipyInterceptor):\n    async def intercept(self, context: ExecutionContext, next_fn: NextFn):\n        return await next_fn()\n\n\ndef ApiDecorator():\n    return apply_decorators(\n        ApiNotFoundResponse(UnauthorizedResponse),\n        UseInterceptors(TestInterceptor)\n    )\n\n\n@Controller()\n@ApiTags('App')\n@ApiDecorator()\n@UseFilters(Http2ExceptionFilter)\nclass AppController:\n    provider: Annotated[AppProvider, Inject()]\n\n    @NoSwagger()\n    @Render('index.html')\n    @Get()\n    async def test(\n            self,\n            req: Annotated[Request, Req()],\n            res: Annotated[Response, Res()],\n            headers: Annotated[dict, Header()],\n            cookies: Annotated[dict, Cookie()],\n            user_id: Annotated[str, Session('user_id')],\n            sessions: Annotated[dict, Session()]\n    ):\n        # req.session['user_id'] = 2\n        # res.cookie('test', 'test-cookie')\n        logger.info(sessions)\n        raise HttpException(HttpStatus.UNAUTHORIZED, HttpStatusMessages.UNAUTHORIZED)\n        # return {'title': 'Hello'}\n        # return await res.render('index.html', {'title': 'Hello'})\n\n    @Post()\n    @ApiBody(TestBody, ApiConsumer.MULTIPART)\n    @ApiCreatedResponse()\n    @ApiResponse(401, UnauthorizedResponse)\n    @ApiOkResponse()\n    @UseInterceptors(TestMethodInterceptor)\n    @ApiParameter(\n        Parameter(in_=ParameterLocation.QUERY, name=\"param\", schema=Schema(type=\"string\"))\n    )\n    @UseFilters(HttpExceptionFilter)\n    async def post(\n            self,\n            res: Annotated[Response, Res()],\n            user: Annotated[str, User()],\n            body: Annotated[TestBody, Body('latin-1')]\n    ):\n        print(user)\n        file_path = os.path.join(os.path.dirname(__file__), f\"nestipy_{body.image.filename}\")\n        file = open(file_path, \"wb\")\n        shutil.copyfileobj(body.image.file, file)\n        file.close()\n        return {\"uploaded\": \"Ok\"}\n        # raise HttpException(HttpStatus.UNAUTHORIZED, HttpStatusMessages.UNAUTHORIZED)\n",
      "is_package": true
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/router/router_proxy.py",
      "lineno": 113,
      "name": "next_fn_interceptor",
      "code": "import dataclasses\nimport os\nimport sys\nimport traceback\nimport typing\nfrom typing import Type, Union\n\nfrom pydantic import BaseModel\n\nfrom nestipy.common.exception import HttpException\nfrom nestipy.common.exception.http import ExceptionDetail, RequestTrack, Traceback\nfrom nestipy.common.exception.message import HttpStatusMessages\nfrom nestipy.common.exception.status import HttpStatus\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.logger import logger\nfrom nestipy.common.utils import snakecase_to_camelcase\nfrom nestipy.core.exception.processor import ExceptionFilterHandler\nfrom nestipy.core.guards import GuardProcessor\nfrom nestipy.core.interceptor import RequestInterceptor\nfrom nestipy.core.middleware import MiddlewareExecutor\nfrom nestipy.core.template import TemplateRendererProcessor\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.ioc import RequestContextContainer\nfrom nestipy.types_ import NextFn, CallableHandler\nfrom .route_explorer import RouteExplorer\nfrom ..adapter.http_adapter import HttpAdapter\nfrom ..context.execution_context import ExecutionContext\nfrom ...openapi.openapi_docs.v3 import Operation, PathItem, Response as ApiResponse\n\n\nclass RouterProxy:\n    def __init__(self, router: HttpAdapter, ):\n        self.router = router\n        self._template_processor = TemplateRendererProcessor(router)\n\n    def apply_routes(self, modules: list[Union[Type, object]], prefix: str = \"\"):\n        _prefix: Union[str | None] = f\"/{prefix.strip('/')}\" if prefix is not None and prefix.strip() != \"\" else None\n        json_paths = {}\n        json_schemas = {}\n        for module_ref in modules:\n            routes = RouteExplorer.explore(module_ref)\n            for route in routes:\n                path = f\"{_prefix.rstrip('/')}/{route['path'].strip('/')}\".rstrip('/') if _prefix else route['path']\n                methods = route['request_method']\n                method_name = route['method_name']\n                controller = route['controller']\n                handler = self.create_request_handler(module_ref, controller, method_name)\n                for method in methods:\n                    getattr(self.router, method.lower())(path, handler, route)\n                    # OPEN API REGISTER\n                    if path in json_paths:\n                        route_path = json_paths[path]\n                    else:\n                        route_path = {}\n                    if \"responses\" not in route['openapi'].keys():\n                        route['openapi'][\"responses\"] = {200: ApiResponse()}\n                    json_schemas = {**json_schemas, **route['schemas']}\n                    if 'no_swagger' not in route['openapi'].keys():\n                        route_path[method.lower()] = Operation(\n                            **route['openapi'],\n                            summary=snakecase_to_camelcase(method_name)\n                        )\n                        json_paths[path] = route_path\n        paths = {}\n        for path, op in json_paths.items():\n            paths[path] = PathItem(**op)\n        return paths, json_schemas\n\n    def create_request_handler(\n            self,\n            module_ref: Type,\n            controller: Union[object, Type],\n            method_name: str\n    ) -> CallableHandler:\n\n        async def request_handler(req: \"Request\", res: \"Response\", next_fn: NextFn):\n\n            context_container = RequestContextContainer.get_instance()\n            container = NestipyContainer.get_instance()\n            controller_method_handler = getattr(controller, method_name)\n            execution_context = ExecutionContext(\n                self.router,\n                module_ref,\n                controller,\n                controller_method_handler,\n                req,\n                res\n            )\n            # setup container for query params, route params, request, response, session, etc..\n            context_container.set_execution_context(execution_context)\n            handler_response: Response\n            try:\n                # TODO : Refactor\n                guard_processor: GuardProcessor = await NestipyContainer.get_instance().get(GuardProcessor)\n                can_activate = await guard_processor.process(execution_context)\n                if not can_activate[0]:\n                    # Raise error\n                    raise HttpException(\n                        HttpStatus.UNAUTHORIZED,\n                        HttpStatusMessages.UNAUTHORIZED,\n                        details=f\"Not authorized from guard {can_activate[1]}\"\n                    )\n\n                # create next_function that call catch\n                async def next_fn_middleware(ex: typing.Any = None):\n                    if ex is not None:\n                        return await self._ensure_response(res, await next_fn(ex))\n                    return await container.get(controller, method_name)\n\n                async def next_fn_interceptor(ex: typing.Any = None):\n                    if ex is not None:\n                        return await self._ensure_response(res, await next_fn(ex))\n                    return await MiddlewareExecutor(req, res, next_fn_middleware).execute()\n\n                #  execute Interceptor by using middleware execution as next_handler\n                interceptor: RequestInterceptor = await container.get(RequestInterceptor)\n                result = await interceptor.intercept(execution_context, next_fn_interceptor)\n                if result is None:\n                    raise HttpException(\n                        HttpStatus.BAD_REQUEST,\n                        \"Handler not called because of interceptor: Invalid Request\"\n                    )\n                # process template rendering\n                if self._template_processor.can_process(controller_method_handler, result):\n                    result = await res.html(self._template_processor.render())\n                # transform result to response\n                handler_response = await self._ensure_response(res, result)\n\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                if not isinstance(e, HttpException):\n                    e = HttpException(HttpStatus.INTERNAL_SERVER_ERROR, str(e), str(tb))\n                track = self.get_full_traceback_details(req, e.message, os.getcwd())\n                e.track_back = track\n                # Call exception catch\n                exception_handler = await container.get(ExceptionFilterHandler)\n                result = await exception_handler.catch(e, execution_context)\n                if result:\n                    handler_response = await self._ensure_response(res, result)\n                else:\n                    handler_response = await self._ensure_response(res, await next_fn(e))\n            finally:\n                #  reset request context container\n                context_container.destroy()\n            return handler_response\n\n        return request_handler\n\n    @classmethod\n    async def _ensure_response(cls, res: \"Response\", result: Union[\"Response\", str, dict, list]) -> \"Response\":\n\n        if isinstance(result, (str, int, float)):\n            return await res.send(content=str(result))\n        elif isinstance(result, (list, dict)):\n            return await res.json(content=result)\n        elif dataclasses.is_dataclass(result):\n            return await res.json(\n                content=dataclasses.asdict(typing.cast(dataclasses.dataclass, result)),\n            )\n        elif isinstance(result, BaseModel):\n            return await res.json(content=result.dict())\n        elif isinstance(result, Response):\n            return result\n        else:\n            return await res.json(content={'error': 'Unknown response format'}, status_code=403)\n\n    @classmethod\n    def get_code_context(cls, filename, lineno, n):\n        try:\n            with open(filename, 'r') as file:\n                lines = file.readlines()\n            return ''.join(lines)\n        except Exception as e:\n            return f\"Could not read file {filename}: {str(e)}\"\n\n    @classmethod\n    def get_full_traceback_details(cls, req: Request, exception: typing.Any, file_path: str):\n        exc_type, exc_value, exc_tb = sys.exc_info()\n        traceback_details = []\n\n        # Extracting traceback details\n        tb = exc_tb\n        while tb is not None:\n            filename: str = tb.tb_frame.f_code.co_filename\n            frame_info = Traceback(\n                filename=f\"{filename.replace(file_path, '').strip('/')}\",\n                lineno=tb.tb_lineno,\n                name=tb.tb_frame.f_code.co_name,\n                code=cls.get_code_context(tb.tb_frame.f_code.co_filename, tb.tb_lineno, 5),\n                is_package=filename.startswith(file_path)\n            )\n            traceback_details.append(frame_info)\n            tb = tb.tb_next\n        return ExceptionDetail(\n            exception=exception,\n            type=exc_type.__name__,\n            root=file_path,\n            traceback=traceback_details,\n            request=RequestTrack(method=req.method, host=req.host),\n            message=str(exc_value)\n        )\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/middleware/executor.py",
      "lineno": 56,
      "name": "execute",
      "code": "import inspect\nimport re\nimport traceback\nfrom typing import Callable, Any\n\nfrom nestipy.ioc import MiddlewareContainer, MiddlewareProxy\n\nfrom nestipy.common.logger import logger\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.middleware import NestipyMiddleware\nfrom nestipy.types_ import HTTPMethod\n\n\ndef uniq_middleware_list(data: list[MiddlewareProxy]) -> list:\n    uniq_middleware = []\n    uniq_data = []\n    for d in data:\n        if d.middleware not in uniq_middleware:\n            uniq_data.append(d)\n            uniq_middleware.append(d.middleware)\n    return uniq_data\n\n\nclass MiddlewareExecutor:\n    def __init__(self, req: Request, res: Response, next_fn: Callable):\n        self.container = MiddlewareContainer.get_instance()\n        # load all middleware inside a container\n        self._middlewares: list[MiddlewareProxy] = self.container.all()\n        self._req = req\n        self._res = res\n        self._next_fn = next_fn\n\n    async def execute(self):\n        middleware_to_apply = []\n        for proxy in self._middlewares:\n            if (self._is_match(proxy.route.url) and not self._is_exclude\n                (proxy.path_excludes,\n                 proxy.route.url\n                 ) and self._is_method_match(\n                proxy.route.method\n            )\n            ):\n                for p in proxy.middlewares:\n                    p = MiddlewareProxy.form_dict(\n                        p,\n                        proxy.route,\n                        proxy.path_excludes\n                    )\n                    self.container.add_singleton(p)\n                    middleware_to_apply.append(p)\n        # get all middleware that match request path\n        if len(middleware_to_apply) == 0:\n            # if no middleware call next_fn that call handler\n            return await self._next_fn()\n        middleware_to_apply = uniq_middleware_list(middleware_to_apply)\n        return await self._recursively_call_middleware(0, middleware_to_apply)\n\n    async def _create_middleware_callable(self, proxy: MiddlewareProxy):\n        if inspect.isclass(proxy.middleware) and issubclass(proxy.middleware, NestipyMiddleware):\n            try:\n                #  get instance of Middleware\n                instance = await self.container.get(proxy)\n                # get use method if it is a middleware class\n                return getattr(instance, 'use')\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                return None\n        elif inspect.isfunction(proxy.middleware):\n            return proxy.middleware\n        else:\n            raise Exception('Middleware must be a function or a class that extends NestipyMiddleware')\n\n    async def _recursively_call_middleware(self, index: int, middlewares: list[MiddlewareProxy]) -> Any:\n        current = middlewares[index]\n        to_call = await self._create_middleware_callable(current)\n        if index != len(middlewares) - 1:\n            # create next_fn that cal next middleware\n            async def next_fn():\n                return await self._recursively_call_middleware(index + 1, middlewares)\n\n            return await to_call(self._req, self._res, next_fn)\n        else:\n            return await to_call(self._req, self._res, self._next_fn)\n\n    def _is_match(self, to_match: str, route: str = None) -> bool:\n        pattern = re.compile(f\"^{to_match}\")\n        mitch = pattern.match(route or self._req.path, )\n        return mitch is not None\n\n    def _is_method_match(self, method: list[HTTPMethod]) -> bool:\n        if 'ALL' in method or 'ANY' in method:\n            return True\n        else:\n            return self._req.method.upper() in [m.upper() for m in method]\n\n    def _is_exclude(self, excludes: list[str], to_match: str) -> bool:\n        for ex in excludes:\n            if self._is_match(to_match, ex):\n                return True\n        return False\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/middleware/executor.py",
      "lineno": 83,
      "name": "_recursively_call_middleware",
      "code": "import inspect\nimport re\nimport traceback\nfrom typing import Callable, Any\n\nfrom nestipy.ioc import MiddlewareContainer, MiddlewareProxy\n\nfrom nestipy.common.logger import logger\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.middleware import NestipyMiddleware\nfrom nestipy.types_ import HTTPMethod\n\n\ndef uniq_middleware_list(data: list[MiddlewareProxy]) -> list:\n    uniq_middleware = []\n    uniq_data = []\n    for d in data:\n        if d.middleware not in uniq_middleware:\n            uniq_data.append(d)\n            uniq_middleware.append(d.middleware)\n    return uniq_data\n\n\nclass MiddlewareExecutor:\n    def __init__(self, req: Request, res: Response, next_fn: Callable):\n        self.container = MiddlewareContainer.get_instance()\n        # load all middleware inside a container\n        self._middlewares: list[MiddlewareProxy] = self.container.all()\n        self._req = req\n        self._res = res\n        self._next_fn = next_fn\n\n    async def execute(self):\n        middleware_to_apply = []\n        for proxy in self._middlewares:\n            if (self._is_match(proxy.route.url) and not self._is_exclude\n                (proxy.path_excludes,\n                 proxy.route.url\n                 ) and self._is_method_match(\n                proxy.route.method\n            )\n            ):\n                for p in proxy.middlewares:\n                    p = MiddlewareProxy.form_dict(\n                        p,\n                        proxy.route,\n                        proxy.path_excludes\n                    )\n                    self.container.add_singleton(p)\n                    middleware_to_apply.append(p)\n        # get all middleware that match request path\n        if len(middleware_to_apply) == 0:\n            # if no middleware call next_fn that call handler\n            return await self._next_fn()\n        middleware_to_apply = uniq_middleware_list(middleware_to_apply)\n        return await self._recursively_call_middleware(0, middleware_to_apply)\n\n    async def _create_middleware_callable(self, proxy: MiddlewareProxy):\n        if inspect.isclass(proxy.middleware) and issubclass(proxy.middleware, NestipyMiddleware):\n            try:\n                #  get instance of Middleware\n                instance = await self.container.get(proxy)\n                # get use method if it is a middleware class\n                return getattr(instance, 'use')\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                return None\n        elif inspect.isfunction(proxy.middleware):\n            return proxy.middleware\n        else:\n            raise Exception('Middleware must be a function or a class that extends NestipyMiddleware')\n\n    async def _recursively_call_middleware(self, index: int, middlewares: list[MiddlewareProxy]) -> Any:\n        current = middlewares[index]\n        to_call = await self._create_middleware_callable(current)\n        if index != len(middlewares) - 1:\n            # create next_fn that cal next middleware\n            async def next_fn():\n                return await self._recursively_call_middleware(index + 1, middlewares)\n\n            return await to_call(self._req, self._res, next_fn)\n        else:\n            return await to_call(self._req, self._res, self._next_fn)\n\n    def _is_match(self, to_match: str, route: str = None) -> bool:\n        pattern = re.compile(f\"^{to_match}\")\n        mitch = pattern.match(route or self._req.path, )\n        return mitch is not None\n\n    def _is_method_match(self, method: list[HTTPMethod]) -> bool:\n        if 'ALL' in method or 'ANY' in method:\n            return True\n        else:\n            return self._req.method.upper() in [m.upper() for m in method]\n\n    def _is_exclude(self, excludes: list[str], to_match: str) -> bool:\n        for ex in excludes:\n            if self._is_match(to_match, ex):\n                return True\n        return False\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/common/middleware/session.py",
      "lineno": 48,
      "name": "use",
      "code": "import dataclasses\nfrom base64 import b64decode, b64encode\nfrom typing import Type, Union, Literal\n\nimport itsdangerous\nimport ujson\nfrom itsdangerous.exc import BadSignature\n\nfrom nestipy.common.decorator import Injectable\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.middleware.interface import NestipyMiddleware\nfrom nestipy.types_ import NextFn\n\n\n@dataclasses.dataclass\nclass SessionOption:\n    secret_key: str = ''\n    session_cookie: str = \"session\"\n    max_age: Union[int, None] = 14 * 24 * 60 * 60\n    path: str = \"/\"\n    same_site: Literal[\"lax\", \"strict\", \"none\"] = \"lax\"\n    https_only: bool = False\n    domain: Union[str, None] = None\n\n\ndef session(option: SessionOption = SessionOption()) -> Type:\n    @Injectable()\n    class SessionMiddleware(NestipyMiddleware):\n\n        async def use(self, req: Request, res: Response, next_fn: NextFn):\n            initial_session_was_empty = True\n            signer = itsdangerous.TimestampSigner(str(option.secret_key))\n            security_flags = \"httponly; samesite=\" + option.same_site\n            if option.https_only:\n                security_flags += \"; secure\"\n            if option.domain is not None:\n                security_flags += f\"; domain={option.domain}\"\n            if option.session_cookie in req.cookies:\n                data = req.cookies[option.session_cookie].encode(\"utf-8\")\n                try:\n                    un_sign_data = signer.unsign(data, max_age=option.max_age)\n                    req.session = ujson.loads(b64decode(un_sign_data))\n                    initial_session_was_empty = False\n                except BadSignature:\n                    req.session = {}\n            else:\n                req.session = {}\n            result = await next_fn()\n            cookie_max_age = f\"Max-Age={option.max_age}; \" if option.max_age else \"\"\n            header_value = \", \".join([\n                f\"{key}={value}; path={option.path}; {cookie_max_age}{security_flags}\"\n                for (key, value) in res.cookies()\n            ])\n            if header_value:\n                header_value += \", \"\n            if req.session:\n                data = b64encode(ujson.dumps(req.session).encode(\"utf-8\"))\n                sign_data = signer.sign(data)\n                header_value += \"{session_cookie}={data}; path={path}; {max_age}{security_flags}\".format(  # noqa E501\n                    session_cookie=option.session_cookie,\n                    data=sign_data.decode(\"utf-8\"),\n                    path=option.path,\n                    max_age=f\"Max-Age={option.max_age}; \" if option.max_age else \"\",\n                    security_flags=security_flags,\n                )\n                res.header('Set-Cookie', header_value)\n            elif initial_session_was_empty:\n                header_value += \"{session_cookie}={data}; path={path}; {expires}{security_flags}\".format(  # noqa E501\n                    session_cookie=option.session_cookie,\n                    data=\"null\",\n                    path=option.path,\n                    expires=\"expires=Thu, 01 Jan 1970 00:00:00 GMT; \",\n                    security_flags=security_flags,\n                )\n                res.header(\"Set-Cookie\", header_value)\n\n            return result\n\n    return SessionMiddleware\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/middleware/executor.py",
      "lineno": 81,
      "name": "next_fn",
      "code": "import inspect\nimport re\nimport traceback\nfrom typing import Callable, Any\n\nfrom nestipy.ioc import MiddlewareContainer, MiddlewareProxy\n\nfrom nestipy.common.logger import logger\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.middleware import NestipyMiddleware\nfrom nestipy.types_ import HTTPMethod\n\n\ndef uniq_middleware_list(data: list[MiddlewareProxy]) -> list:\n    uniq_middleware = []\n    uniq_data = []\n    for d in data:\n        if d.middleware not in uniq_middleware:\n            uniq_data.append(d)\n            uniq_middleware.append(d.middleware)\n    return uniq_data\n\n\nclass MiddlewareExecutor:\n    def __init__(self, req: Request, res: Response, next_fn: Callable):\n        self.container = MiddlewareContainer.get_instance()\n        # load all middleware inside a container\n        self._middlewares: list[MiddlewareProxy] = self.container.all()\n        self._req = req\n        self._res = res\n        self._next_fn = next_fn\n\n    async def execute(self):\n        middleware_to_apply = []\n        for proxy in self._middlewares:\n            if (self._is_match(proxy.route.url) and not self._is_exclude\n                (proxy.path_excludes,\n                 proxy.route.url\n                 ) and self._is_method_match(\n                proxy.route.method\n            )\n            ):\n                for p in proxy.middlewares:\n                    p = MiddlewareProxy.form_dict(\n                        p,\n                        proxy.route,\n                        proxy.path_excludes\n                    )\n                    self.container.add_singleton(p)\n                    middleware_to_apply.append(p)\n        # get all middleware that match request path\n        if len(middleware_to_apply) == 0:\n            # if no middleware call next_fn that call handler\n            return await self._next_fn()\n        middleware_to_apply = uniq_middleware_list(middleware_to_apply)\n        return await self._recursively_call_middleware(0, middleware_to_apply)\n\n    async def _create_middleware_callable(self, proxy: MiddlewareProxy):\n        if inspect.isclass(proxy.middleware) and issubclass(proxy.middleware, NestipyMiddleware):\n            try:\n                #  get instance of Middleware\n                instance = await self.container.get(proxy)\n                # get use method if it is a middleware class\n                return getattr(instance, 'use')\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                return None\n        elif inspect.isfunction(proxy.middleware):\n            return proxy.middleware\n        else:\n            raise Exception('Middleware must be a function or a class that extends NestipyMiddleware')\n\n    async def _recursively_call_middleware(self, index: int, middlewares: list[MiddlewareProxy]) -> Any:\n        current = middlewares[index]\n        to_call = await self._create_middleware_callable(current)\n        if index != len(middlewares) - 1:\n            # create next_fn that cal next middleware\n            async def next_fn():\n                return await self._recursively_call_middleware(index + 1, middlewares)\n\n            return await to_call(self._req, self._res, next_fn)\n        else:\n            return await to_call(self._req, self._res, self._next_fn)\n\n    def _is_match(self, to_match: str, route: str = None) -> bool:\n        pattern = re.compile(f\"^{to_match}\")\n        mitch = pattern.match(route or self._req.path, )\n        return mitch is not None\n\n    def _is_method_match(self, method: list[HTTPMethod]) -> bool:\n        if 'ALL' in method or 'ANY' in method:\n            return True\n        else:\n            return self._req.method.upper() in [m.upper() for m in method]\n\n    def _is_exclude(self, excludes: list[str], to_match: str) -> bool:\n        for ex in excludes:\n            if self._is_match(to_match, ex):\n                return True\n        return False\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/middleware/executor.py",
      "lineno": 85,
      "name": "_recursively_call_middleware",
      "code": "import inspect\nimport re\nimport traceback\nfrom typing import Callable, Any\n\nfrom nestipy.ioc import MiddlewareContainer, MiddlewareProxy\n\nfrom nestipy.common.logger import logger\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.middleware import NestipyMiddleware\nfrom nestipy.types_ import HTTPMethod\n\n\ndef uniq_middleware_list(data: list[MiddlewareProxy]) -> list:\n    uniq_middleware = []\n    uniq_data = []\n    for d in data:\n        if d.middleware not in uniq_middleware:\n            uniq_data.append(d)\n            uniq_middleware.append(d.middleware)\n    return uniq_data\n\n\nclass MiddlewareExecutor:\n    def __init__(self, req: Request, res: Response, next_fn: Callable):\n        self.container = MiddlewareContainer.get_instance()\n        # load all middleware inside a container\n        self._middlewares: list[MiddlewareProxy] = self.container.all()\n        self._req = req\n        self._res = res\n        self._next_fn = next_fn\n\n    async def execute(self):\n        middleware_to_apply = []\n        for proxy in self._middlewares:\n            if (self._is_match(proxy.route.url) and not self._is_exclude\n                (proxy.path_excludes,\n                 proxy.route.url\n                 ) and self._is_method_match(\n                proxy.route.method\n            )\n            ):\n                for p in proxy.middlewares:\n                    p = MiddlewareProxy.form_dict(\n                        p,\n                        proxy.route,\n                        proxy.path_excludes\n                    )\n                    self.container.add_singleton(p)\n                    middleware_to_apply.append(p)\n        # get all middleware that match request path\n        if len(middleware_to_apply) == 0:\n            # if no middleware call next_fn that call handler\n            return await self._next_fn()\n        middleware_to_apply = uniq_middleware_list(middleware_to_apply)\n        return await self._recursively_call_middleware(0, middleware_to_apply)\n\n    async def _create_middleware_callable(self, proxy: MiddlewareProxy):\n        if inspect.isclass(proxy.middleware) and issubclass(proxy.middleware, NestipyMiddleware):\n            try:\n                #  get instance of Middleware\n                instance = await self.container.get(proxy)\n                # get use method if it is a middleware class\n                return getattr(instance, 'use')\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                return None\n        elif inspect.isfunction(proxy.middleware):\n            return proxy.middleware\n        else:\n            raise Exception('Middleware must be a function or a class that extends NestipyMiddleware')\n\n    async def _recursively_call_middleware(self, index: int, middlewares: list[MiddlewareProxy]) -> Any:\n        current = middlewares[index]\n        to_call = await self._create_middleware_callable(current)\n        if index != len(middlewares) - 1:\n            # create next_fn that cal next middleware\n            async def next_fn():\n                return await self._recursively_call_middleware(index + 1, middlewares)\n\n            return await to_call(self._req, self._res, next_fn)\n        else:\n            return await to_call(self._req, self._res, self._next_fn)\n\n    def _is_match(self, to_match: str, route: str = None) -> bool:\n        pattern = re.compile(f\"^{to_match}\")\n        mitch = pattern.match(route or self._req.path, )\n        return mitch is not None\n\n    def _is_method_match(self, method: list[HTTPMethod]) -> bool:\n        if 'ALL' in method or 'ANY' in method:\n            return True\n        else:\n            return self._req.method.upper() in [m.upper() for m in method]\n\n    def _is_exclude(self, excludes: list[str], to_match: str) -> bool:\n        for ex in excludes:\n            if self._is_match(to_match, ex):\n                return True\n        return False\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/common/middleware/session.py",
      "lineno": 48,
      "name": "use",
      "code": "import dataclasses\nfrom base64 import b64decode, b64encode\nfrom typing import Type, Union, Literal\n\nimport itsdangerous\nimport ujson\nfrom itsdangerous.exc import BadSignature\n\nfrom nestipy.common.decorator import Injectable\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.middleware.interface import NestipyMiddleware\nfrom nestipy.types_ import NextFn\n\n\n@dataclasses.dataclass\nclass SessionOption:\n    secret_key: str = ''\n    session_cookie: str = \"session\"\n    max_age: Union[int, None] = 14 * 24 * 60 * 60\n    path: str = \"/\"\n    same_site: Literal[\"lax\", \"strict\", \"none\"] = \"lax\"\n    https_only: bool = False\n    domain: Union[str, None] = None\n\n\ndef session(option: SessionOption = SessionOption()) -> Type:\n    @Injectable()\n    class SessionMiddleware(NestipyMiddleware):\n\n        async def use(self, req: Request, res: Response, next_fn: NextFn):\n            initial_session_was_empty = True\n            signer = itsdangerous.TimestampSigner(str(option.secret_key))\n            security_flags = \"httponly; samesite=\" + option.same_site\n            if option.https_only:\n                security_flags += \"; secure\"\n            if option.domain is not None:\n                security_flags += f\"; domain={option.domain}\"\n            if option.session_cookie in req.cookies:\n                data = req.cookies[option.session_cookie].encode(\"utf-8\")\n                try:\n                    un_sign_data = signer.unsign(data, max_age=option.max_age)\n                    req.session = ujson.loads(b64decode(un_sign_data))\n                    initial_session_was_empty = False\n                except BadSignature:\n                    req.session = {}\n            else:\n                req.session = {}\n            result = await next_fn()\n            cookie_max_age = f\"Max-Age={option.max_age}; \" if option.max_age else \"\"\n            header_value = \", \".join([\n                f\"{key}={value}; path={option.path}; {cookie_max_age}{security_flags}\"\n                for (key, value) in res.cookies()\n            ])\n            if header_value:\n                header_value += \", \"\n            if req.session:\n                data = b64encode(ujson.dumps(req.session).encode(\"utf-8\"))\n                sign_data = signer.sign(data)\n                header_value += \"{session_cookie}={data}; path={path}; {max_age}{security_flags}\".format(  # noqa E501\n                    session_cookie=option.session_cookie,\n                    data=sign_data.decode(\"utf-8\"),\n                    path=option.path,\n                    max_age=f\"Max-Age={option.max_age}; \" if option.max_age else \"\",\n                    security_flags=security_flags,\n                )\n                res.header('Set-Cookie', header_value)\n            elif initial_session_was_empty:\n                header_value += \"{session_cookie}={data}; path={path}; {expires}{security_flags}\".format(  # noqa E501\n                    session_cookie=option.session_cookie,\n                    data=\"null\",\n                    path=option.path,\n                    expires=\"expires=Thu, 01 Jan 1970 00:00:00 GMT; \",\n                    security_flags=security_flags,\n                )\n                res.header(\"Set-Cookie\", header_value)\n\n            return result\n\n    return SessionMiddleware\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/core/router/router_proxy.py",
      "lineno": 108,
      "name": "next_fn_middleware",
      "code": "import dataclasses\nimport os\nimport sys\nimport traceback\nimport typing\nfrom typing import Type, Union\n\nfrom pydantic import BaseModel\n\nfrom nestipy.common.exception import HttpException\nfrom nestipy.common.exception.http import ExceptionDetail, RequestTrack, Traceback\nfrom nestipy.common.exception.message import HttpStatusMessages\nfrom nestipy.common.exception.status import HttpStatus\nfrom nestipy.common.http_ import Request, Response\nfrom nestipy.common.logger import logger\nfrom nestipy.common.utils import snakecase_to_camelcase\nfrom nestipy.core.exception.processor import ExceptionFilterHandler\nfrom nestipy.core.guards import GuardProcessor\nfrom nestipy.core.interceptor import RequestInterceptor\nfrom nestipy.core.middleware import MiddlewareExecutor\nfrom nestipy.core.template import TemplateRendererProcessor\nfrom nestipy.ioc import NestipyContainer\nfrom nestipy.ioc import RequestContextContainer\nfrom nestipy.types_ import NextFn, CallableHandler\nfrom .route_explorer import RouteExplorer\nfrom ..adapter.http_adapter import HttpAdapter\nfrom ..context.execution_context import ExecutionContext\nfrom ...openapi.openapi_docs.v3 import Operation, PathItem, Response as ApiResponse\n\n\nclass RouterProxy:\n    def __init__(self, router: HttpAdapter, ):\n        self.router = router\n        self._template_processor = TemplateRendererProcessor(router)\n\n    def apply_routes(self, modules: list[Union[Type, object]], prefix: str = \"\"):\n        _prefix: Union[str | None] = f\"/{prefix.strip('/')}\" if prefix is not None and prefix.strip() != \"\" else None\n        json_paths = {}\n        json_schemas = {}\n        for module_ref in modules:\n            routes = RouteExplorer.explore(module_ref)\n            for route in routes:\n                path = f\"{_prefix.rstrip('/')}/{route['path'].strip('/')}\".rstrip('/') if _prefix else route['path']\n                methods = route['request_method']\n                method_name = route['method_name']\n                controller = route['controller']\n                handler = self.create_request_handler(module_ref, controller, method_name)\n                for method in methods:\n                    getattr(self.router, method.lower())(path, handler, route)\n                    # OPEN API REGISTER\n                    if path in json_paths:\n                        route_path = json_paths[path]\n                    else:\n                        route_path = {}\n                    if \"responses\" not in route['openapi'].keys():\n                        route['openapi'][\"responses\"] = {200: ApiResponse()}\n                    json_schemas = {**json_schemas, **route['schemas']}\n                    if 'no_swagger' not in route['openapi'].keys():\n                        route_path[method.lower()] = Operation(\n                            **route['openapi'],\n                            summary=snakecase_to_camelcase(method_name)\n                        )\n                        json_paths[path] = route_path\n        paths = {}\n        for path, op in json_paths.items():\n            paths[path] = PathItem(**op)\n        return paths, json_schemas\n\n    def create_request_handler(\n            self,\n            module_ref: Type,\n            controller: Union[object, Type],\n            method_name: str\n    ) -> CallableHandler:\n\n        async def request_handler(req: \"Request\", res: \"Response\", next_fn: NextFn):\n\n            context_container = RequestContextContainer.get_instance()\n            container = NestipyContainer.get_instance()\n            controller_method_handler = getattr(controller, method_name)\n            execution_context = ExecutionContext(\n                self.router,\n                module_ref,\n                controller,\n                controller_method_handler,\n                req,\n                res\n            )\n            # setup container for query params, route params, request, response, session, etc..\n            context_container.set_execution_context(execution_context)\n            handler_response: Response\n            try:\n                # TODO : Refactor\n                guard_processor: GuardProcessor = await NestipyContainer.get_instance().get(GuardProcessor)\n                can_activate = await guard_processor.process(execution_context)\n                if not can_activate[0]:\n                    # Raise error\n                    raise HttpException(\n                        HttpStatus.UNAUTHORIZED,\n                        HttpStatusMessages.UNAUTHORIZED,\n                        details=f\"Not authorized from guard {can_activate[1]}\"\n                    )\n\n                # create next_function that call catch\n                async def next_fn_middleware(ex: typing.Any = None):\n                    if ex is not None:\n                        return await self._ensure_response(res, await next_fn(ex))\n                    return await container.get(controller, method_name)\n\n                async def next_fn_interceptor(ex: typing.Any = None):\n                    if ex is not None:\n                        return await self._ensure_response(res, await next_fn(ex))\n                    return await MiddlewareExecutor(req, res, next_fn_middleware).execute()\n\n                #  execute Interceptor by using middleware execution as next_handler\n                interceptor: RequestInterceptor = await container.get(RequestInterceptor)\n                result = await interceptor.intercept(execution_context, next_fn_interceptor)\n                if result is None:\n                    raise HttpException(\n                        HttpStatus.BAD_REQUEST,\n                        \"Handler not called because of interceptor: Invalid Request\"\n                    )\n                # process template rendering\n                if self._template_processor.can_process(controller_method_handler, result):\n                    result = await res.html(self._template_processor.render())\n                # transform result to response\n                handler_response = await self._ensure_response(res, result)\n\n            except Exception as e:\n                tb = traceback.format_exc()\n                logger.error(e)\n                logger.error(tb)\n                if not isinstance(e, HttpException):\n                    e = HttpException(HttpStatus.INTERNAL_SERVER_ERROR, str(e), str(tb))\n                track = self.get_full_traceback_details(req, e.message, os.getcwd())\n                e.track_back = track\n                # Call exception catch\n                exception_handler = await container.get(ExceptionFilterHandler)\n                result = await exception_handler.catch(e, execution_context)\n                if result:\n                    handler_response = await self._ensure_response(res, result)\n                else:\n                    handler_response = await self._ensure_response(res, await next_fn(e))\n            finally:\n                #  reset request context container\n                context_container.destroy()\n            return handler_response\n\n        return request_handler\n\n    @classmethod\n    async def _ensure_response(cls, res: \"Response\", result: Union[\"Response\", str, dict, list]) -> \"Response\":\n\n        if isinstance(result, (str, int, float)):\n            return await res.send(content=str(result))\n        elif isinstance(result, (list, dict)):\n            return await res.json(content=result)\n        elif dataclasses.is_dataclass(result):\n            return await res.json(\n                content=dataclasses.asdict(typing.cast(dataclasses.dataclass, result)),\n            )\n        elif isinstance(result, BaseModel):\n            return await res.json(content=result.dict())\n        elif isinstance(result, Response):\n            return result\n        else:\n            return await res.json(content={'error': 'Unknown response format'}, status_code=403)\n\n    @classmethod\n    def get_code_context(cls, filename, lineno, n):\n        try:\n            with open(filename, 'r') as file:\n                lines = file.readlines()\n            return ''.join(lines)\n        except Exception as e:\n            return f\"Could not read file {filename}: {str(e)}\"\n\n    @classmethod\n    def get_full_traceback_details(cls, req: Request, exception: typing.Any, file_path: str):\n        exc_type, exc_value, exc_tb = sys.exc_info()\n        traceback_details = []\n\n        # Extracting traceback details\n        tb = exc_tb\n        while tb is not None:\n            filename: str = tb.tb_frame.f_code.co_filename\n            frame_info = Traceback(\n                filename=f\"{filename.replace(file_path, '').strip('/')}\",\n                lineno=tb.tb_lineno,\n                name=tb.tb_frame.f_code.co_name,\n                code=cls.get_code_context(tb.tb_frame.f_code.co_filename, tb.tb_lineno, 5),\n                is_package=filename.startswith(file_path)\n            )\n            traceback_details.append(frame_info)\n            tb = tb.tb_next\n        return ExceptionDetail(\n            exception=exception,\n            type=exc_type.__name__,\n            root=file_path,\n            traceback=traceback_details,\n            request=RequestTrack(method=req.method, host=req.host),\n            message=str(exc_value)\n        )\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/ioc/container.py",
      "lineno": 238,
      "name": "get",
      "code": "import inspect\nfrom functools import lru_cache\nfrom typing import Type, Union, Any, Optional, Callable, Awaitable, TYPE_CHECKING\n\nfrom nestipy.metadata import ClassMetadata, CtxDepKey, ModuleMetadata, ProviderToken, Reflect\nfrom .context_container import RequestContextContainer\nfrom .dependency import TypeAnnotated\nfrom .meta import ContainerHelper\nfrom .utils import uniq\n\nif TYPE_CHECKING:\n    from .provider import ModuleProviderDict\n\n_INIT = \"__init__\"\n\n\nclass NestipyContainer:\n    _instance: \"NestipyContainer\" = None\n    _services = {}\n    _global_service_instances = {}\n    _singleton_instances = {}\n    _singleton_classes = set()\n    helper = ContainerHelper()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super(NestipyContainer, cls).__new__(cls, *args, **kwargs)\n        return cls._instance\n\n    @classmethod\n    def get_instance(cls, *args, **kwargs):\n        return NestipyContainer(*args, **kwargs)\n\n    def add_transient(self, service: Type):\n        self._services[service] = service\n\n    def add_singleton(self, service: Type):\n        self._services[service] = service\n        self._singleton_classes.add(service)\n\n    def get_all_services(self) -> list:\n        return list(self._services.keys())\n\n    def add_singleton_instance(self, service: Union[Type, str], service_instance: object):\n        self._singleton_instances[service] = service_instance\n\n    def get_all_singleton_instance(self) -> list:\n        return [v for k, v in self._singleton_instances.items()]\n\n    @classmethod\n    @lru_cache()\n    def get_global_providers(cls) -> list:\n        global_providers = []\n        for service in cls._services:\n            if service in global_providers:\n                continue\n            metadata: ClassMetadata = Reflect.get_metadata(service, ClassMetadata.Metadata, None)\n            if metadata is not None:\n                is_global = Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Global, False)\n                is_root = Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Root, False)\n                if is_global or is_root:\n                    global_providers += Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Providers, [])\n        return uniq(global_providers)\n\n    @classmethod\n    def get_dependency_metadata(cls, service: Union[Type, object]) -> list:\n        from .provider import ModuleProviderDict\n        # extract global data from _service, not from module because all provider is already saved in _services of\n        # container\n        metadata: ClassMetadata = Reflect.get_metadata(service, ClassMetadata.Metadata, None)\n        if metadata is not None:\n            global_providers = cls.get_global_providers()\n            providers, import_providers = metadata.get_service_providers()\n            uniq_providers = []\n            for m in uniq(providers + global_providers + import_providers):\n                if isinstance(m, ModuleProviderDict):\n                    uniq_providers.append(m.token)\n                else:\n                    uniq_providers.append(m)\n            return uniq(uniq_providers)\n        # raise ValueError(f\"Dependency Metadata not found  for {service.__name__} service \")\n        return []\n\n    @classmethod\n    async def _resolve_context_service(cls, name: str, dep_key: TypeAnnotated, annotation: Union[Type, Any]):\n        context_container = RequestContextContainer.get_instance()\n        callback = dep_key.metadata.callback\n        if inspect.iscoroutinefunction(callback):\n            return await callback(name, dep_key.metadata.token, annotation, context_container)\n        else:\n            return callback(name, dep_key.metadata.token, annotation, context_container)\n\n    async def _resolve_module_provider_dict(self, instance: \"ModuleProviderDict\", search_scope: list):\n        if instance.value:\n            return instance.value\n        elif instance.existing:\n            if isinstance(instance.existing, ProviderToken):\n                return await self.get(instance.existing.key)\n            else:\n                return await self.get(instance.existing)\n        elif instance.use_class:\n            return await self.get(instance.use_class)\n        elif instance.factory:\n            return await self.resolve_factory(\n                factory=instance.factory,\n                inject=instance.inject,\n                search_scope=search_scope\n            )\n\n        else:\n            return None\n\n    async def _check_exist_singleton(self, key: Union[Type, str]):\n        from .provider import ModuleProviderDict\n        if key in self._singleton_instances:\n            instance = self._singleton_instances[key]\n            # to keep improve\n            if isinstance(instance, ModuleProviderDict):\n                search_scope = self.get_dependency_metadata(instance)\n                if instance.token in search_scope:\n                    value = await self._resolve_module_provider_dict(instance, search_scope=search_scope)\n                    # update singleton instance to have the async value from ModuleProviderDict\n                    self._singleton_instances[key] = value\n                    return value\n                else:\n                    raise ValueError(\n                        f\"Service {instance.__class__.__name__} \"\n                        f\"not found in scope\")\n            else:\n                return instance\n        return None\n\n    def _check_service(self, key: Union[Type, str], origin: Optional[list] = None) -> tuple:\n        if key not in self._services:\n            raise ValueError(f\"Service {key} not found\")\n        service = self._services[key]\n        if service in (origin or []):\n            raise ValueError(f\"Circular dependency found  for {service.__name__} service \")\n        return service, origin or set()\n\n    async def _resolve_property(\n            self,\n            key: Union[Type, str],\n            origin: Optional[list] = None,\n            disable_scope: bool = False\n    ):\n        service, origin = self._check_service(key, origin)\n        search_scope = self.get_dependency_metadata(service)\n        origin.add(service)\n        annotations: dict = getattr(service, '__annotations__', {})\n        for name, param_annotation in annotations.items():\n            annotation, dep_key = self.helper.get_type_from_annotation(param_annotation)\n            if dep_key.metadata.key is not CtxDepKey.Service:\n                dependency = await self._resolve_context_service(name, dep_key, annotation)\n                setattr(service, name, dependency)\n            elif dep_key.metadata.token in search_scope or annotation in search_scope or disable_scope:\n                dependency = await self.get(dep_key.metadata.token or annotation)\n                setattr(service, name, dependency)\n            else:\n                _name: str = annotation.__name__ if not isinstance(annotation, str) else annotation\n                raise ValueError(f\"Service {_name} not found in scope {search_scope}\")\n        origin.remove(service)\n        self._services[key] = service\n\n    async def _get_method_dependency(self, method_to_resolve: Callable, search_scope: list,\n                                     disable_scope: bool = False):\n        params = inspect.signature(method_to_resolve).parameters\n        args = {}\n        for name, param in params.items():\n            if name != 'self' and param.annotation is not inspect.Parameter.empty:\n                annotation, dep_key = self.helper.get_type_from_annotation(param.annotation)\n                if dep_key.metadata.key is not CtxDepKey.Service:\n                    dependency = await self._resolve_context_service(name, dep_key, annotation)\n                    args[name] = dependency\n                elif dep_key.metadata.token in search_scope or annotation in search_scope or disable_scope:\n                    dependency = await self.get(dep_key.metadata.token or annotation)\n                    args[name] = dependency\n                else:\n                    _name: str = annotation.__name__ if not isinstance(annotation, str) else annotation\n                    raise ValueError(f\"Service {_name} not found in scope {search_scope}\")\n        return args\n\n    @classmethod\n    async def _call_method(cls, method: Callable, args: dict):\n        if inspect.iscoroutinefunction(method):\n            return await method(**args)\n        return method(**args)\n\n    async def resolve_factory(self, factory: Callable, inject: list, search_scope: list, disable_scope: bool = False):\n        search_scope_by_inject = [m for m in inject if m in search_scope]\n        args = await self._get_method_dependency(\n            method_to_resolve=factory,\n            search_scope=search_scope_by_inject,\n            disable_scope=disable_scope\n        )\n        return await self._call_method(method=factory, args=args)\n\n    async def _resolve_method(\n            self,\n            key: Union[Type, str, object],\n            method: str = _INIT,\n            origin: Optional[list] = None,\n            disable_scope: bool = False\n    ):\n        service, origin = self._check_service(key, origin)\n        search_scope = self.get_dependency_metadata(service)\n        origin.add(service)\n        method_to_resolve = getattr(service, method, None)\n        if not method_to_resolve:\n            raise Exception(f\"Method {method} not found in {service.__name__} service \")\n        args = await self._get_method_dependency(method_to_resolve, search_scope, disable_scope=disable_scope)\n        if method == _INIT:\n            result = service(**args)\n            if service in self._singleton_classes:\n                self._singleton_instances[service] = result\n        else:\n            # Service must be an instance (controller)\n            instance = await self.get(key)\n            instance_method = getattr(instance, method, method_to_resolve)\n            result = await self._call_method(instance_method, args)\n\n        origin.remove(service)\n        return result\n\n    async def get(\n            self,\n            key: Union[Type, str],\n            method: str = _INIT,\n            origin: Optional[list] = None,\n            disable_scope: Optional[bool] = False\n    ) -> Awaitable[object]:\n        in_singleton = await self._check_exist_singleton(key=key)\n        if in_singleton:\n            if method == _INIT:\n                return in_singleton\n        else:\n            await self._resolve_property(key, origin=origin, disable_scope=disable_scope)\n        return await self._resolve_method(key, method=method, origin=origin, disable_scope=disable_scope)\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/ioc/container.py",
      "lineno": 220,
      "name": "_resolve_method",
      "code": "import inspect\nfrom functools import lru_cache\nfrom typing import Type, Union, Any, Optional, Callable, Awaitable, TYPE_CHECKING\n\nfrom nestipy.metadata import ClassMetadata, CtxDepKey, ModuleMetadata, ProviderToken, Reflect\nfrom .context_container import RequestContextContainer\nfrom .dependency import TypeAnnotated\nfrom .meta import ContainerHelper\nfrom .utils import uniq\n\nif TYPE_CHECKING:\n    from .provider import ModuleProviderDict\n\n_INIT = \"__init__\"\n\n\nclass NestipyContainer:\n    _instance: \"NestipyContainer\" = None\n    _services = {}\n    _global_service_instances = {}\n    _singleton_instances = {}\n    _singleton_classes = set()\n    helper = ContainerHelper()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super(NestipyContainer, cls).__new__(cls, *args, **kwargs)\n        return cls._instance\n\n    @classmethod\n    def get_instance(cls, *args, **kwargs):\n        return NestipyContainer(*args, **kwargs)\n\n    def add_transient(self, service: Type):\n        self._services[service] = service\n\n    def add_singleton(self, service: Type):\n        self._services[service] = service\n        self._singleton_classes.add(service)\n\n    def get_all_services(self) -> list:\n        return list(self._services.keys())\n\n    def add_singleton_instance(self, service: Union[Type, str], service_instance: object):\n        self._singleton_instances[service] = service_instance\n\n    def get_all_singleton_instance(self) -> list:\n        return [v for k, v in self._singleton_instances.items()]\n\n    @classmethod\n    @lru_cache()\n    def get_global_providers(cls) -> list:\n        global_providers = []\n        for service in cls._services:\n            if service in global_providers:\n                continue\n            metadata: ClassMetadata = Reflect.get_metadata(service, ClassMetadata.Metadata, None)\n            if metadata is not None:\n                is_global = Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Global, False)\n                is_root = Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Root, False)\n                if is_global or is_root:\n                    global_providers += Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Providers, [])\n        return uniq(global_providers)\n\n    @classmethod\n    def get_dependency_metadata(cls, service: Union[Type, object]) -> list:\n        from .provider import ModuleProviderDict\n        # extract global data from _service, not from module because all provider is already saved in _services of\n        # container\n        metadata: ClassMetadata = Reflect.get_metadata(service, ClassMetadata.Metadata, None)\n        if metadata is not None:\n            global_providers = cls.get_global_providers()\n            providers, import_providers = metadata.get_service_providers()\n            uniq_providers = []\n            for m in uniq(providers + global_providers + import_providers):\n                if isinstance(m, ModuleProviderDict):\n                    uniq_providers.append(m.token)\n                else:\n                    uniq_providers.append(m)\n            return uniq(uniq_providers)\n        # raise ValueError(f\"Dependency Metadata not found  for {service.__name__} service \")\n        return []\n\n    @classmethod\n    async def _resolve_context_service(cls, name: str, dep_key: TypeAnnotated, annotation: Union[Type, Any]):\n        context_container = RequestContextContainer.get_instance()\n        callback = dep_key.metadata.callback\n        if inspect.iscoroutinefunction(callback):\n            return await callback(name, dep_key.metadata.token, annotation, context_container)\n        else:\n            return callback(name, dep_key.metadata.token, annotation, context_container)\n\n    async def _resolve_module_provider_dict(self, instance: \"ModuleProviderDict\", search_scope: list):\n        if instance.value:\n            return instance.value\n        elif instance.existing:\n            if isinstance(instance.existing, ProviderToken):\n                return await self.get(instance.existing.key)\n            else:\n                return await self.get(instance.existing)\n        elif instance.use_class:\n            return await self.get(instance.use_class)\n        elif instance.factory:\n            return await self.resolve_factory(\n                factory=instance.factory,\n                inject=instance.inject,\n                search_scope=search_scope\n            )\n\n        else:\n            return None\n\n    async def _check_exist_singleton(self, key: Union[Type, str]):\n        from .provider import ModuleProviderDict\n        if key in self._singleton_instances:\n            instance = self._singleton_instances[key]\n            # to keep improve\n            if isinstance(instance, ModuleProviderDict):\n                search_scope = self.get_dependency_metadata(instance)\n                if instance.token in search_scope:\n                    value = await self._resolve_module_provider_dict(instance, search_scope=search_scope)\n                    # update singleton instance to have the async value from ModuleProviderDict\n                    self._singleton_instances[key] = value\n                    return value\n                else:\n                    raise ValueError(\n                        f\"Service {instance.__class__.__name__} \"\n                        f\"not found in scope\")\n            else:\n                return instance\n        return None\n\n    def _check_service(self, key: Union[Type, str], origin: Optional[list] = None) -> tuple:\n        if key not in self._services:\n            raise ValueError(f\"Service {key} not found\")\n        service = self._services[key]\n        if service in (origin or []):\n            raise ValueError(f\"Circular dependency found  for {service.__name__} service \")\n        return service, origin or set()\n\n    async def _resolve_property(\n            self,\n            key: Union[Type, str],\n            origin: Optional[list] = None,\n            disable_scope: bool = False\n    ):\n        service, origin = self._check_service(key, origin)\n        search_scope = self.get_dependency_metadata(service)\n        origin.add(service)\n        annotations: dict = getattr(service, '__annotations__', {})\n        for name, param_annotation in annotations.items():\n            annotation, dep_key = self.helper.get_type_from_annotation(param_annotation)\n            if dep_key.metadata.key is not CtxDepKey.Service:\n                dependency = await self._resolve_context_service(name, dep_key, annotation)\n                setattr(service, name, dependency)\n            elif dep_key.metadata.token in search_scope or annotation in search_scope or disable_scope:\n                dependency = await self.get(dep_key.metadata.token or annotation)\n                setattr(service, name, dependency)\n            else:\n                _name: str = annotation.__name__ if not isinstance(annotation, str) else annotation\n                raise ValueError(f\"Service {_name} not found in scope {search_scope}\")\n        origin.remove(service)\n        self._services[key] = service\n\n    async def _get_method_dependency(self, method_to_resolve: Callable, search_scope: list,\n                                     disable_scope: bool = False):\n        params = inspect.signature(method_to_resolve).parameters\n        args = {}\n        for name, param in params.items():\n            if name != 'self' and param.annotation is not inspect.Parameter.empty:\n                annotation, dep_key = self.helper.get_type_from_annotation(param.annotation)\n                if dep_key.metadata.key is not CtxDepKey.Service:\n                    dependency = await self._resolve_context_service(name, dep_key, annotation)\n                    args[name] = dependency\n                elif dep_key.metadata.token in search_scope or annotation in search_scope or disable_scope:\n                    dependency = await self.get(dep_key.metadata.token or annotation)\n                    args[name] = dependency\n                else:\n                    _name: str = annotation.__name__ if not isinstance(annotation, str) else annotation\n                    raise ValueError(f\"Service {_name} not found in scope {search_scope}\")\n        return args\n\n    @classmethod\n    async def _call_method(cls, method: Callable, args: dict):\n        if inspect.iscoroutinefunction(method):\n            return await method(**args)\n        return method(**args)\n\n    async def resolve_factory(self, factory: Callable, inject: list, search_scope: list, disable_scope: bool = False):\n        search_scope_by_inject = [m for m in inject if m in search_scope]\n        args = await self._get_method_dependency(\n            method_to_resolve=factory,\n            search_scope=search_scope_by_inject,\n            disable_scope=disable_scope\n        )\n        return await self._call_method(method=factory, args=args)\n\n    async def _resolve_method(\n            self,\n            key: Union[Type, str, object],\n            method: str = _INIT,\n            origin: Optional[list] = None,\n            disable_scope: bool = False\n    ):\n        service, origin = self._check_service(key, origin)\n        search_scope = self.get_dependency_metadata(service)\n        origin.add(service)\n        method_to_resolve = getattr(service, method, None)\n        if not method_to_resolve:\n            raise Exception(f\"Method {method} not found in {service.__name__} service \")\n        args = await self._get_method_dependency(method_to_resolve, search_scope, disable_scope=disable_scope)\n        if method == _INIT:\n            result = service(**args)\n            if service in self._singleton_classes:\n                self._singleton_instances[service] = result\n        else:\n            # Service must be an instance (controller)\n            instance = await self.get(key)\n            instance_method = getattr(instance, method, method_to_resolve)\n            result = await self._call_method(instance_method, args)\n\n        origin.remove(service)\n        return result\n\n    async def get(\n            self,\n            key: Union[Type, str],\n            method: str = _INIT,\n            origin: Optional[list] = None,\n            disable_scope: Optional[bool] = False\n    ) -> Awaitable[object]:\n        in_singleton = await self._check_exist_singleton(key=key)\n        if in_singleton:\n            if method == _INIT:\n                return in_singleton\n        else:\n            await self._resolve_property(key, origin=origin, disable_scope=disable_scope)\n        return await self._resolve_method(key, method=method, origin=origin, disable_scope=disable_scope)\n",
      "is_package": false
    },
    {
      "filename": "home/tsiresy/work/python/nestipy/src/nestipy/ioc/container.py",
      "lineno": 186,
      "name": "_call_method",
      "code": "import inspect\nfrom functools import lru_cache\nfrom typing import Type, Union, Any, Optional, Callable, Awaitable, TYPE_CHECKING\n\nfrom nestipy.metadata import ClassMetadata, CtxDepKey, ModuleMetadata, ProviderToken, Reflect\nfrom .context_container import RequestContextContainer\nfrom .dependency import TypeAnnotated\nfrom .meta import ContainerHelper\nfrom .utils import uniq\n\nif TYPE_CHECKING:\n    from .provider import ModuleProviderDict\n\n_INIT = \"__init__\"\n\n\nclass NestipyContainer:\n    _instance: \"NestipyContainer\" = None\n    _services = {}\n    _global_service_instances = {}\n    _singleton_instances = {}\n    _singleton_classes = set()\n    helper = ContainerHelper()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super(NestipyContainer, cls).__new__(cls, *args, **kwargs)\n        return cls._instance\n\n    @classmethod\n    def get_instance(cls, *args, **kwargs):\n        return NestipyContainer(*args, **kwargs)\n\n    def add_transient(self, service: Type):\n        self._services[service] = service\n\n    def add_singleton(self, service: Type):\n        self._services[service] = service\n        self._singleton_classes.add(service)\n\n    def get_all_services(self) -> list:\n        return list(self._services.keys())\n\n    def add_singleton_instance(self, service: Union[Type, str], service_instance: object):\n        self._singleton_instances[service] = service_instance\n\n    def get_all_singleton_instance(self) -> list:\n        return [v for k, v in self._singleton_instances.items()]\n\n    @classmethod\n    @lru_cache()\n    def get_global_providers(cls) -> list:\n        global_providers = []\n        for service in cls._services:\n            if service in global_providers:\n                continue\n            metadata: ClassMetadata = Reflect.get_metadata(service, ClassMetadata.Metadata, None)\n            if metadata is not None:\n                is_global = Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Global, False)\n                is_root = Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Root, False)\n                if is_global or is_root:\n                    global_providers += Reflect.get_metadata(metadata.get_module(), ModuleMetadata.Providers, [])\n        return uniq(global_providers)\n\n    @classmethod\n    def get_dependency_metadata(cls, service: Union[Type, object]) -> list:\n        from .provider import ModuleProviderDict\n        # extract global data from _service, not from module because all provider is already saved in _services of\n        # container\n        metadata: ClassMetadata = Reflect.get_metadata(service, ClassMetadata.Metadata, None)\n        if metadata is not None:\n            global_providers = cls.get_global_providers()\n            providers, import_providers = metadata.get_service_providers()\n            uniq_providers = []\n            for m in uniq(providers + global_providers + import_providers):\n                if isinstance(m, ModuleProviderDict):\n                    uniq_providers.append(m.token)\n                else:\n                    uniq_providers.append(m)\n            return uniq(uniq_providers)\n        # raise ValueError(f\"Dependency Metadata not found  for {service.__name__} service \")\n        return []\n\n    @classmethod\n    async def _resolve_context_service(cls, name: str, dep_key: TypeAnnotated, annotation: Union[Type, Any]):\n        context_container = RequestContextContainer.get_instance()\n        callback = dep_key.metadata.callback\n        if inspect.iscoroutinefunction(callback):\n            return await callback(name, dep_key.metadata.token, annotation, context_container)\n        else:\n            return callback(name, dep_key.metadata.token, annotation, context_container)\n\n    async def _resolve_module_provider_dict(self, instance: \"ModuleProviderDict\", search_scope: list):\n        if instance.value:\n            return instance.value\n        elif instance.existing:\n            if isinstance(instance.existing, ProviderToken):\n                return await self.get(instance.existing.key)\n            else:\n                return await self.get(instance.existing)\n        elif instance.use_class:\n            return await self.get(instance.use_class)\n        elif instance.factory:\n            return await self.resolve_factory(\n                factory=instance.factory,\n                inject=instance.inject,\n                search_scope=search_scope\n            )\n\n        else:\n            return None\n\n    async def _check_exist_singleton(self, key: Union[Type, str]):\n        from .provider import ModuleProviderDict\n        if key in self._singleton_instances:\n            instance = self._singleton_instances[key]\n            # to keep improve\n            if isinstance(instance, ModuleProviderDict):\n                search_scope = self.get_dependency_metadata(instance)\n                if instance.token in search_scope:\n                    value = await self._resolve_module_provider_dict(instance, search_scope=search_scope)\n                    # update singleton instance to have the async value from ModuleProviderDict\n                    self._singleton_instances[key] = value\n                    return value\n                else:\n                    raise ValueError(\n                        f\"Service {instance.__class__.__name__} \"\n                        f\"not found in scope\")\n            else:\n                return instance\n        return None\n\n    def _check_service(self, key: Union[Type, str], origin: Optional[list] = None) -> tuple:\n        if key not in self._services:\n            raise ValueError(f\"Service {key} not found\")\n        service = self._services[key]\n        if service in (origin or []):\n            raise ValueError(f\"Circular dependency found  for {service.__name__} service \")\n        return service, origin or set()\n\n    async def _resolve_property(\n            self,\n            key: Union[Type, str],\n            origin: Optional[list] = None,\n            disable_scope: bool = False\n    ):\n        service, origin = self._check_service(key, origin)\n        search_scope = self.get_dependency_metadata(service)\n        origin.add(service)\n        annotations: dict = getattr(service, '__annotations__', {})\n        for name, param_annotation in annotations.items():\n            annotation, dep_key = self.helper.get_type_from_annotation(param_annotation)\n            if dep_key.metadata.key is not CtxDepKey.Service:\n                dependency = await self._resolve_context_service(name, dep_key, annotation)\n                setattr(service, name, dependency)\n            elif dep_key.metadata.token in search_scope or annotation in search_scope or disable_scope:\n                dependency = await self.get(dep_key.metadata.token or annotation)\n                setattr(service, name, dependency)\n            else:\n                _name: str = annotation.__name__ if not isinstance(annotation, str) else annotation\n                raise ValueError(f\"Service {_name} not found in scope {search_scope}\")\n        origin.remove(service)\n        self._services[key] = service\n\n    async def _get_method_dependency(self, method_to_resolve: Callable, search_scope: list,\n                                     disable_scope: bool = False):\n        params = inspect.signature(method_to_resolve).parameters\n        args = {}\n        for name, param in params.items():\n            if name != 'self' and param.annotation is not inspect.Parameter.empty:\n                annotation, dep_key = self.helper.get_type_from_annotation(param.annotation)\n                if dep_key.metadata.key is not CtxDepKey.Service:\n                    dependency = await self._resolve_context_service(name, dep_key, annotation)\n                    args[name] = dependency\n                elif dep_key.metadata.token in search_scope or annotation in search_scope or disable_scope:\n                    dependency = await self.get(dep_key.metadata.token or annotation)\n                    args[name] = dependency\n                else:\n                    _name: str = annotation.__name__ if not isinstance(annotation, str) else annotation\n                    raise ValueError(f\"Service {_name} not found in scope {search_scope}\")\n        return args\n\n    @classmethod\n    async def _call_method(cls, method: Callable, args: dict):\n        if inspect.iscoroutinefunction(method):\n            return await method(**args)\n        return method(**args)\n\n    async def resolve_factory(self, factory: Callable, inject: list, search_scope: list, disable_scope: bool = False):\n        search_scope_by_inject = [m for m in inject if m in search_scope]\n        args = await self._get_method_dependency(\n            method_to_resolve=factory,\n            search_scope=search_scope_by_inject,\n            disable_scope=disable_scope\n        )\n        return await self._call_method(method=factory, args=args)\n\n    async def _resolve_method(\n            self,\n            key: Union[Type, str, object],\n            method: str = _INIT,\n            origin: Optional[list] = None,\n            disable_scope: bool = False\n    ):\n        service, origin = self._check_service(key, origin)\n        search_scope = self.get_dependency_metadata(service)\n        origin.add(service)\n        method_to_resolve = getattr(service, method, None)\n        if not method_to_resolve:\n            raise Exception(f\"Method {method} not found in {service.__name__} service \")\n        args = await self._get_method_dependency(method_to_resolve, search_scope, disable_scope=disable_scope)\n        if method == _INIT:\n            result = service(**args)\n            if service in self._singleton_classes:\n                self._singleton_instances[service] = result\n        else:\n            # Service must be an instance (controller)\n            instance = await self.get(key)\n            instance_method = getattr(instance, method, method_to_resolve)\n            result = await self._call_method(instance_method, args)\n\n        origin.remove(service)\n        return result\n\n    async def get(\n            self,\n            key: Union[Type, str],\n            method: str = _INIT,\n            origin: Optional[list] = None,\n            disable_scope: Optional[bool] = False\n    ) -> Awaitable[object]:\n        in_singleton = await self._check_exist_singleton(key=key)\n        if in_singleton:\n            if method == _INIT:\n                return in_singleton\n        else:\n            await self._resolve_property(key, origin=origin, disable_scope=disable_scope)\n        return await self._resolve_method(key, method=method, origin=origin, disable_scope=disable_scope)\n",
      "is_package": false
    },
    {
      "filename": "app_controller.py",
      "lineno": 104,
      "name": "test",
      "code": "import dataclasses\nimport os.path\nimport shutil\nfrom typing import Any, Annotated, Optional, Type\n\nfrom pydantic import BaseModel\n\nfrom app_provider import AppProvider\nfrom nestipy.common import Controller, Injectable, Post, Get, logger, UploadFile, HttpStatus, HttpStatusMessages\nfrom nestipy.common import ExceptionFilter, Catch, UseFilters\nfrom nestipy.common import HttpException, apply_decorators\nfrom nestipy.common import NestipyInterceptor, UseInterceptors, Render\nfrom nestipy.common import Request, Response\nfrom nestipy.core import ArgumentHost, ExecutionContext\nfrom nestipy.ioc import Inject, Req, Res, Body, Cookie, Session, Header, create_type_annotated, RequestContextContainer\nfrom nestipy.openapi import ApiResponse, ApiParameter, ApiConsumer\nfrom nestipy.openapi import ApiTags, ApiOkResponse, ApiNotFoundResponse, ApiCreatedResponse, NoSwagger, ApiBody\nfrom nestipy.openapi.openapi_docs.v3 import Parameter, ParameterLocation, Schema\nfrom nestipy.types_ import NextFn\n\n\ndef user_callback(_name: str, _token: Optional[str], _type_ref: Type, _request_context: RequestContextContainer):\n    return \"User\"\n\n\nUser = create_type_annotated(user_callback, \"user\")\n\n\nclass Test2(BaseModel):\n    name2: str\n\n\n@dataclasses.dataclass\nclass Test3:\n    name3: str\n\n\nclass TestBody(BaseModel):\n    image: UploadFile\n    test2: Test2\n    test3: Test3\n\n\nclass UnauthorizedResponse(BaseModel):\n    status: int = 401\n    message: str\n    details: str\n\n\n@Catch()\nclass HttpExceptionFilter(ExceptionFilter):\n    async def catch(self, exception: HttpException, host: ArgumentHost) -> Any:\n        print('Catcher')\n\n\n@Catch()\nclass Http2ExceptionFilter(ExceptionFilter):\n    async def catch(self, exception: HttpException, host: ArgumentHost) -> Any:\n        print('Catcher2')\n        return None\n\n\n@Injectable()\nclass TestInterceptor(NestipyInterceptor):\n    async def intercept(self, context: ExecutionContext, next_fn: NextFn):\n        return await next_fn()\n\n\n@Injectable()\nclass TestMethodInterceptor(NestipyInterceptor):\n    async def intercept(self, context: ExecutionContext, next_fn: NextFn):\n        return await next_fn()\n\n\ndef ApiDecorator():\n    return apply_decorators(\n        ApiNotFoundResponse(UnauthorizedResponse),\n        UseInterceptors(TestInterceptor)\n    )\n\n\n@Controller()\n@ApiTags('App')\n@ApiDecorator()\n@UseFilters(Http2ExceptionFilter)\nclass AppController:\n    provider: Annotated[AppProvider, Inject()]\n\n    @NoSwagger()\n    @Render('index.html')\n    @Get()\n    async def test(\n            self,\n            req: Annotated[Request, Req()],\n            res: Annotated[Response, Res()],\n            headers: Annotated[dict, Header()],\n            cookies: Annotated[dict, Cookie()],\n            user_id: Annotated[str, Session('user_id')],\n            sessions: Annotated[dict, Session()]\n    ):\n        # req.session['user_id'] = 2\n        # res.cookie('test', 'test-cookie')\n        logger.info(sessions)\n        raise HttpException(HttpStatus.UNAUTHORIZED, HttpStatusMessages.UNAUTHORIZED)\n        # return {'title': 'Hello'}\n        # return await res.render('index.html', {'title': 'Hello'})\n\n    @Post()\n    @ApiBody(TestBody, ApiConsumer.MULTIPART)\n    @ApiCreatedResponse()\n    @ApiResponse(401, UnauthorizedResponse)\n    @ApiOkResponse()\n    @UseInterceptors(TestMethodInterceptor)\n    @ApiParameter(\n        Parameter(in_=ParameterLocation.QUERY, name=\"param\", schema=Schema(type=\"string\"))\n    )\n    @UseFilters(HttpExceptionFilter)\n    async def post(\n            self,\n            res: Annotated[Response, Res()],\n            user: Annotated[str, User()],\n            body: Annotated[TestBody, Body('latin-1')]\n    ):\n        print(user)\n        file_path = os.path.join(os.path.dirname(__file__), f\"nestipy_{body.image.filename}\")\n        file = open(file_path, \"wb\")\n        shutil.copyfileobj(body.image.file, file)\n        file.close()\n        return {\"uploaded\": \"Ok\"}\n        # raise HttpException(HttpStatus.UNAUTHORIZED, HttpStatusMessages.UNAUTHORIZED)\n",
      "is_package": true
    }
  ],
  "framework": {
    "python": "3.11.6",
    "nestipy": "1.0.0a2"
  }
}